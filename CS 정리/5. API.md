### API 
Application Programming Interface

API는 애플리케이션을 프로그래밍 할 때, 보다 쉽게 할 수 있도록 해주는 도구들을 의미

interface라는 용어를 통해 추상화와 캡슐화의 개념이 들어갔다고 생각할 수 있다.

### Rest API 
Representational State Transfer로 http 기반 통신 방법이며 웹 서비스 아키텍처를 의미한다.

### API Endpoint
API를 호출하기 위한 http 메소드와 url을 포함한다.

### HTTP 메소드 - 각 설명 적을 예정

1. get
	- 서버에서 데이터를 가져옴
	- 서버의 상태나 데이터를 변경하지 않음(안전한 method)
	- 요청에 대한 응답 값이 동일하다(멱등성)"
	- ==cashing이 가능하다==
		- `GET` 요청에서 **캐싱 가능**하다는 것은, 클라이언트(브라우저)나 중간 캐시 서버가 서버로부터 받은 응답 데이터를 **저장해 두었다가** 동일한 요청이 들어올 때 **다시 서버로 요청을 보내지 않고, 저장된 응답을 재사용할 수 있다는 의미**
		- 캐시될 수 있는 대상은 **정적 리소스**가 대부분이다
		- header에 캐시의 유효기간, 새로고침 정책 등을 설정할 수 있다
	- url에 쿼리 문자열을 사용해서 정보 전달이 가능하다
		- ?로 시작해서 여러 매개변수는 &로 구분된다.
		- ex) /user?id=123&sex=male
	- 민감 정보는 브라우저 기록, 서버 로그에 남기 때문에 보내지 않는다.
	
2. post
	- **새로운 데이터를 전송**하고, **새로운 리소스를 생성**
	- 서버에 데이터를 전송하여 **서버의 상태를 변경** -> 새로운 데이터가 들어가서 적용 되는 것을 생각 하면 된다.
	- **요청 본문(body)**에 데이터를 포함하여 서버로 다양한 형식으로 전송 -> 대용량 데이터를 보내는 것에 적합함
	- **민감한 정보**를 전송하는 데 적합
	- 요청이 서버의 데이터를 **변경**할 수 있음(안전하지 않은 method)
	- 멱등성도 없음
	- cashing 안 됨

3. put
	- **기존 리소스를 대체하거나 업데이트**하는 데 사용
	- 멱등성을 가지고 있다. 즉, 서버의 상태가 변하지는 않는다.
	- 리소스의 전체 대체 (Replace): 사용자의 정보를 대체할 때, 사용자 정보를 완전 덮에쓰게 된다.
	- 만약 `PUT` 요청이 보내졌는데, 서버에 해당 리소스가 존재하지 않는다면, 서버는 **새로운 리소스를 생성**할 수 있다 -> 이러면 멱등성의 원리 때문에 안 되는거 아닌가 싶다
	- cashing 안 됨
	
4. delete
	- 특정 리소스를 **삭제**
	- 서버의 상태를 **변경**(안전하지 않음)
	- cashing 안 됨
	- 요청 body가 없음// 가끔 조건을 추가하기 위해 넣기도 함
	
5. patch
	- **기존 리소스의 일부를 수정** 부분적으로 업데이트
	- 서버의 상태가 변경된다(안전하지 않음, 멱등성 x)
	- cashing x
	- put과 차이점
		- put은 전체를 대체하고 patch는 일부를 대체한다
6. head
	- **`HEAD`** 메서드는 **`GET`** 메서드와 유사하지만, **본문 없이 응답 헤더만 반환**
	- **리소스의 메타데이터**를 얻는 데 사용 
		- **헤더 정보**(예: `Content-Type`, `Content-Length`, `Last-Modified` 등)를 **확인**
	- **안전하고 멱등성**을 가짐
	- **캐시 유효성**을 확인
	- 연결 속도나 응답 시간 등의 성능을 **네트워크 부하 없이** 측정
1. options
	- **특정 리소스** 또는 **서버 전체**에서 어떤 **HTTP 메서드**들이 허용되는지를 물어보는 것
	- CORS 요청에서 사용됨
	- 클라이언트가 요청을 보내기 전에 **서버가 요청을 허용할지 여부**를 확인하는 프리플라이트 요청에 사용됨
### Endpoint 규칙

1. 경로(url)에 동사가 포함 x
2. 단어의 구분이 필요하면 - 을 사용
3. 자원(API에서 다루는 데이터나 객체)은 기본적으로 복수형으로 표현
4. 단 하나의 자원을 명시적으로 표현 -> users/id와 같이 식별 값이 사용
5. ==자원 간 연관 관계가 있을 경우 이를 URI에 표현==
	- 비즈니스 로직상 더 중요한 대상을 계층 관계에서 앞에 두는 방법

```
상위 자원: `users` (사용자)
연관 자원: `posts` (게시물)
연관 자원: `hash-tags`(해시태그)
하위 자원: `comments` (댓글)
각 사용자는 여러 개의 게시물을 작성 할 수 있다. 1-n
각 게시물에는 여러 개의 댓글이 달릴 수 있다. 1-n
각 게시물에는 여러 개의 해시태그가 있고 각 해시태그에도 여러 개의 게시물이 있다. n-m
/users/{userId}/posts
/users/{userId}/posts/{postId}/comments/{commentId}
/users/{userId}/posets/{postId}/hash-tags/{hash-tagId}

```

### 회원 탈퇴

회원 탈퇴는 러프하게 생각하면 아래처럼 설계가 가능하다고 생각할 수 있다.

DELETE /users

그러나 요구 사항이 **회원 탈퇴 시 곧바로 데이터베이스에서 삭제가 아니라, 비활성 계정으로 만들고, 추후 계정 복구를 고려**한다면 **DELETE로 설계를 하면 안된다.**
이런 경우 데이터베이스에서 사용자 테이블에 status를 active에서 inactive로 변경하는 것이기에
**일부 수정인 PATCH를 활용**해야 한다.

## 세부적인 API 설계

1.  **path variable**
	- 단 하나, 특정 대상을 지목할 때 식별 값을 넣어서 전달
	- ex) /users/Id -> GET /users/{user-id}
2. **query string**\
	- 특정 정보가 포함된 데이터 조회
	- 보통 검색 조회에 사용
	- ex) /users/id?user-id=1&owner-id=2
3. **request body**
	- 보통 json 형식 혹은 form-data 형식으로 보낸다.
4. **request header** 
	- 전송에 관한 기타 정보가 담기는 부분
 5. matrix variable
	 - 각 경로 세그먼트에 추가적인 정보를 **키-값 쌍** 형태로 부여하는 방법
	 - **각 세그먼트에 필터나 추가 정보를 부여**하는 강력한 도구
	 - ex) /users/id;user-id=1;owner-id=2
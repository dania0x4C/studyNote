1. 주요 서비스 중요한 로직 리스트 업
2. 테스트 코드 모듈 단위로 작성
3. 실제 배포에서 docker 서버가 실행되기전에 작동할 수 있도록 구성 조정

```
// 자동으로 재시작
"docker:test:watch": "docker exec linkview-backend yarn test --watchAll",

"docker:test" = "docker exec 최상단 폴더 yarn test"

docker:test 파일경로
```
yarn docker:test src/admin_auth/admin_auth.service.spec.ts  


# 테스트 라우터 리스트 업

1. admin_auth - 끝
	1. login
	2. register
2. ai
	1. naver
	2. epenAI
	
3. api_key
	1. generate
	
4.  auth
	1. login
	2. refresh
	3. register
	4. email/verify
	
5. business_profile
	1. create
	2. update
	3. deactivate
	
6. invoice - 추후에 생각

7. payment - 추후에 생각

8. process

9. refund - 추후에 생각

10. ticket_product
	1. create
	2. update
	3. getTicketProduct
11. user_ticket
	1. remaining
	2. findAll
	3. getTicketDetail
12. user - 전부다

# 데이터 관리 전략
- 단위 서비스 로직 테스트이기 때문에 디비에 연결하지 않는다.
- json 파일로 따로 관리를 하여 불필요한 mock 데이터 생성을 줄인다.
- 각 경계데이터나 다양한 케이스를 미리 제작한다.

# 테스트 예시
```
import { Test, TestingModule } from '@nestjs/testing';
import { AdminAuthService } from './admin_auth.service';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { AdminUsersService } from '../admin_users/admin_users.service';
import * as bcrypt from 'bcrypt';
import { UnauthorizedException } from '@nestjs/common';
const mockAdminUsers = require('../common/database/mockData/admin_user.json');

jest.mock('bcrypt', () => ({
  compareSync: jest.fn(),
  hashSync: jest.fn(),
}));

describe('AdminAuthService', () => {
  let service: AdminAuthService;
  let jwtService: JwtService;
  let configService: ConfigService;
  let adminUsersService: AdminUsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AdminAuthService,
        {
          provide: JwtService,
          useValue: { sign: jest.fn(), verify: jest.fn() },
        },
        {
          provide: ConfigService,
          useValue: { get: jest.fn() },
        },
        {
          provide: AdminUsersService,
          useValue: {
            findByEmail: jest.fn(),
            create: jest.fn(),
            findMe: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get(AdminAuthService);
    jwtService = module.get(JwtService);
    configService = module.get(ConfigService);
    adminUsersService = module.get(AdminUsersService);
  });

  it('emailLogin - 성공', async () => {
    jest.spyOn(adminUsersService, 'findByEmail').mockResolvedValue(mockAdminUsers.active_admin);
    (bcrypt.compareSync as jest.MockedFunction<typeof bcrypt.compareSync>).mockReturnValue(true);
    (jwtService.sign as jest.MockedFunction<typeof jwtService.sign>)
      .mockReturnValueOnce('token')
      .mockReturnValueOnce('refresh-token');
    (configService.get as jest.MockedFunction<typeof configService.get>).mockReturnValue('secret');

    const result = await service.emailLogin(
      mockAdminUsers.active_admin.email,
      mockAdminUsers.active_admin.password,
    );

    expect(result).toEqual({
      token: 'token',
      refreshToken: 'refresh-token',
    });
  });

  it.each`
    case                 | user                           | pwMatch
    ${'user 없음'}       | ${null}                        | ${true}
    ${'비밀번호 불일치'} | ${mockAdminUsers.active_admin} | ${false}
  `('emailLogin - 실패: $case', async ({ user, pwMatch }) => {
    jest.spyOn(adminUsersService, 'findByEmail').mockResolvedValue(user);
    (bcrypt.compareSync as jest.MockedFunction<typeof bcrypt.compareSync>).mockReturnValue(pwMatch);

    await expect(
      service.emailLogin(
        mockAdminUsers.active_admin.email,
        mockAdminUsers.active_admin.password,
      ),
    ).rejects.toThrow(UnauthorizedException);
  });

  it('register - 성공', async () => {
    (bcrypt.hashSync as jest.MockedFunction<typeof bcrypt.hashSync>).mockReturnValue('hashed-pw');
    jest.spyOn(adminUsersService, 'create').mockResolvedValue(mockAdminUsers.active_admin);

    await expect(
      service.register(
        mockAdminUsers.active_admin.email,
        mockAdminUsers.active_admin.password,
        mockAdminUsers.active_admin.name,
      ),
    ).resolves.toBeUndefined();

    expect(adminUsersService.create).toHaveBeenCalledWith(
      mockAdminUsers.active_admin.email,
      'hashed-pw',
      mockAdminUsers.active_admin.name,
    );
  });

  it('refreshToken - 성공 (기존 refreshToken 유지)', async () => {
    const now = Math.floor(Date.now() / 1000);
    const exp = now + 60 * 60 * 24 * 20; // 20일 뒤

    (jwtService.verify as jest.MockedFunction<typeof jwtService.verify>)
      .mockImplementationOnce(() => ({ id: mockAdminUsers.active_admin.id, exp }))
      .mockImplementationOnce(() => ({ id: mockAdminUsers.active_admin.id, exp }));

    (configService.get as jest.MockedFunction<typeof configService.get>).mockReturnValue({
      JWT_REFRESH_SECRET: 'secret',
    });

    jest.spyOn(adminUsersService, 'findMe').mockResolvedValue(mockAdminUsers.active_admin);
    (jwtService.sign as jest.MockedFunction<typeof jwtService.sign>).mockReturnValueOnce('new-access-token');

    const refreshToken = 'refresh-token';

    const result = await service.refreshToken('access-token', refreshToken);

    expect(result).toEqual({
      token: 'new-access-token',
      refreshToken,
    });
  });

  it('refreshToken - 만료일 15일 이하일 때 새 refreshToken 발급', async () => {
    const now = Math.floor(Date.now() / 1000);
    const exp = now + 60 * 60 * 24 * 10; // 10일 남음

    (jwtService.verify as jest.MockedFunction<typeof jwtService.verify>)
      .mockImplementationOnce(() => ({ id: mockAdminUsers.active_admin.id, exp: now + 60 * 60 * 24 })) // accessToken
      .mockImplementationOnce(() => ({ id: mockAdminUsers.active_admin.id, exp })); // refreshToken

    (configService.get as jest.MockedFunction<typeof configService.get>).mockReturnValue({
      JWT_REFRESH_SECRET: 'secret',
    });

    jest.spyOn(adminUsersService, 'findMe').mockResolvedValue(mockAdminUsers.active_admin);

    (jwtService.sign as jest.MockedFunction<typeof jwtService.sign>)
      .mockReturnValueOnce('new-access-token')
      .mockReturnValueOnce('new-refresh-token');

    const result = await service.refreshToken('access-token', 'old-refresh-token');

    expect(result).toEqual({
      token: 'new-access-token',
      refreshToken: 'new-refresh-token',
    });

    expect(jwtService.sign).toHaveBeenCalledTimes(2);
  });

  it.each`
    case                         | accessPayload                 | refreshPayload                | foundUser
    ${'access 토큰 디코드 실패'} | ${null}                       | ${null}                       | ${mockAdminUsers.active_admin}
    ${'ID 불일치'}               | ${{ id: 'a', exp: 1 }}        | ${{ id: 'b', exp: 1 }}        | ${mockAdminUsers.active_admin}
    ${'user 없음'}               | ${{ id: 'admin-id', exp: 1 }} | ${{ id: 'admin-id', exp: 1 }} | ${null}
  `('refreshToken - 실패: $case', async ({ accessPayload, refreshPayload, foundUser }) => {
    (jwtService.verify as jest.MockedFunction<typeof jwtService.verify>)
      .mockImplementationOnce(() => accessPayload)
      .mockImplementationOnce(() => refreshPayload);

    (configService.get as jest.MockedFunction<typeof configService.get>).mockReturnValue({
      JWT_REFRESH_SECRET: 'secret',
    });

    jest.spyOn(adminUsersService, 'findMe').mockResolvedValue(foundUser);

    await expect(service.refreshToken('access', 'refresh')).rejects.toThrow(UnauthorizedException);
  });
});
```

# 정리

| **est 함수**                        | **사용 예시**                                        | **설명**                                          |
| --------------------------------- | ------------------------------------------------ | ----------------------------------------------- |
| jest.fn()                         | sign: jest.fn()                                  | 기본적인 함수 모킹. 호출 기록 추적 및 반환값 설정 가능                |
| jest.mock()                       | jest.mock('bcrypt', ...)                         | 외부 모듈 전체를 모킹                                    |
| jest.spyOn(obj, method)           | jest.spyOn(service, 'findByEmail')               | 기존 객체의 메서드를 감시하고 모킹                             |
| mockReturnValue(value)            | mockReturnValue('token')                         | 항상 특정 값 반환하도록 설정                                |
| mockResolvedValue(value)          | mockResolvedValue(mockUser)                      | Promise.resolve(value) 형태로 반환 (비동기 함수용)         |
| mockImplementationOnce(fn)        | mockImplementationOnce(() => val)                | 한 번만 커스텀 동작, 이후 원래 동작 또는 다른 설정 사용               |
| as jest.MockedFunction<typeof fn> | (bcrypt.compareSync as jest.MockedFunction<...>) | 타입스크립트에서 mockReturnValue 등을 타입 안전하게 사용하기 위한 캐스팅 |
| it.each\``                        | it.each\case \| …``                              | 매개변수 기반 반복 테스트                                  |

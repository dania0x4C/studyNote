**PostgreSQL와 MySQL의 동시성 문제 해결 전략**

  

소규모부터 중규모 서비스에서 **PostgreSQL와 MySQL**을 사용할 때 여러 사용자의 동시 요청으로 **데이터베이스 동시성 문제**가 발생할 수 있습니다. 이러한 문제는 잘못된 데이터 갱신, **race condition**으로 인한 불일치, **중복 요청**에 따른 중복 처리 등으로 나타납니다. 아래에서는 자주 접하는 시나리오별 문제점과 이를 해결하기 위한 **실질적인 전략과 기법**들을 정리합니다. 각 전략의 원리, PostgreSQL/MySQL에서의 적용 방법과 예제를 함께 소개하며, 필요한 경우 실제 코드 예시와 참고 자료를 포함합니다.

  

**동시성 이슈 개요 (충돌 시나리오)**

  

동시성 문제는 **여러 트랜잭션이 같은 데이터에 동시에 접근**할 때 발생합니다. 예를 들어 두 사용자가 동시에 같은 상품을 구매하면 재고 차감 과정에서 잘못된 재고값이 기록되거나(**race condition**), 둘 중 하나의 주문이 누락될 수 있습니다. 주요 시나리오별 문제는 다음과 같습니다:

• **동시 INSERT/UPDATE/DELETE 충돌**: 두 트랜잭션이 동일한 행(row)을 동시에 수정하면 **갱신 손실(Lost Update)**이 발생할 수 있습니다. 한 트랜잭션의 변경을 다른 트랜잭션이 덮어쓰거나 무시하는 문제가 생깁니다.

• **업무 로직 Race Condition**: 주문/재고/포인트/예약 시스템 등에서 동시 처리 시 재고가 음수가 된다거나, **이중 결제**, **이중 예약** 등이 일어날 수 있습니다. 예를 들어 재고가 1개 남은 상품을 두 사용자가 동시에 구매하면, 재고가 -1로 잘못 처리될 수 있습니다.

• **중복 요청 처리**: 사용자가 버튼을 두 번 클릭하거나 네트워크 재시도로 동일한 요청이 반복될 때, **중복된 데이터 생성이나 중복 결제**가 일어날 수 있습니다. 이를 방지하지 않으면 동일 주문이 두 번 들어가거나 결제가 이중으로 이루어질 위험이 있습니다.

• **멀티 인스턴스 환경**: 서비스가 여러 서버 인스턴스로 배포되면, 개별 인스턴스 간에 메모리 공유가 없으므로 하나의 서버에서 적용한 **락/캐시**만으로는 동시성 제어가 되지 않습니다. 모든 인스턴스에 일관된 동시성 제어가 필요하며, 이를 위해 **공유 자원**(DB나 분산 락 등)을 활용해야 합니다.

  

이러한 문제를 해결하기 위해 **데이터베이스 수준의 잠금과 트랜잭션 제어**, **응용(Application) 수준의 전략**을 조합해야 합니다. 아래에 각 전략별 원리와 적용 방법을 PostgreSQL과 MySQL을 중심으로 설명합니다.

  

**행 수준 잠금 (Pessimistic Locking을 통한 동시성 제어)**

  

**행 수준 잠금**은 특정 행을 수정하거나 조회하는 동안 **다른 트랜잭션이 해당 행을 건드리지 못하도록 잠그는 방법**입니다. 이는 **비관적 잠금(pessimistic locking)**의 대표적인 사례로, 충돌이 일어날 가능성이 높다고 가정하고 미리 잠금을 거는 방식입니다 . 행 잠금을 사용하면 동시에 같은 행을 수정하려는 시도를 **순차적으로 직렬화**하여 데이터 정합성을 보장할 수 있습니다. 다만 락을 얻은 트랜잭션이 완료될 때까지 다른 트랜잭션은 대기해야 하므로, **경합이 많을 경우 성능 저하**가 있을 수 있습니다 .

  

**PostgreSQL과 MySQL에서 행 잠금 구현:**

• **SELECT … FOR UPDATE**: 두 DB 모두 트랜잭션 내에서 SELECT ... FOR UPDATE 구문으로 해당 행에 배타적 잠금을 겁니다. 이렇게 하면 **해당 행을 읽은 후 트랜잭션이 끝날 때까지** 다른 트랜잭션이 그 행을 수정하거나 잠그지 못합니다. 예를 들어, 재고 테이블에서 상품 item_id=123의 재고를 확인하고 줄이는 로직은 다음과 같이 구현합니다 :

```
BEGIN;
SELECT stock 
FROM items 
WHERE item_id = 123
FOR UPDATE;
-- 재고 확인 후 조건에 따라 구매 처리
UPDATE items 
SET stock = stock - 1 
WHERE item_id = 123;
COMMIT;
```

여기서 stock = ? 자리에 트랜잭션 시작 시 읽어온 재고 수량을 넣습니다. 예를 들어 item_id=123 상품의 재고가 5였을 때 두 사용자가 동시에 구매 요청을 보내면, 둘 다 ... WHERE item_id=123 AND stock=5로 쿼리를 보낼 것입니다. 먼저 온 쿼리는 재고를 4로 줄이며 성공하지만, 나중 온 쿼리는 stock 값이 이미 4로 변경된 탓에 **조건을 만족하지 못해 실패**합니다. 이렇게 하면 별도의 버전 컬럼 없이도 **재고 수량 자체를 버전으로 활용**하여 동시에 1씩 줄이는 작업의 충돌을 감지할 수 있습니다 . 실패한 쪽 트랜잭션은 재시도 로직을 통해 재고를 다시 읽어 최신 값(4)을 확인하고 재처리하거나, 품절 등의 메시지를 주면 될 것입니다.

  

낙관적 잠금 전략은 **충돌이 드물 때 성능상 이점**이 크고, 읽기 위주의 시스템에서 유용합니다. 다만 충돌 발생 시 애플리케이션 레벨에서 이를 처리해야 하고, **반드시 재시도 등의 보완책**이 필요합니다 . 또한 **충돌이 빈번한 데이터**(예: 하나의 인기 상품 재고를 많은 사용자가 동시에 구매)라면 낙관적 잠금은 반복적인 충돌 발생으로 비효율적일 수 있습니다. 이런 경우 앞서 언급한 **행 잠금 등 비관적 잠금**으로 확실히 순서를 보장하는 편이 나을 수 있습니다. 실제로 **동시성 높은 환경에서는 낙관적 잠금 실패->재시도 루프가 오히려 성능 저하**를 일으킬 수 있으므로, 데이터 특성을 고려해 결정해야 합니다.

  

**트랜잭션 격리 수준 조정 (Isolation Level을 통한 동시성 제어)**

  

데이터베이스는 **트랜잭션 격리 수준**에 따라 동시성 동작과 허용하는 불일치 유형을 달리합니다. SQL 표준 격리 수준으로 **Read Uncommitted**, **Read Committed**, **Repeatable Read**, **Serializable**이 정의되어 있으며, 각각 **더 엄격한 고립**을 제공하는 대신 **성능 희생**이 따릅니다. 격리 수준을 조정하면 특정 동시성 문제 (예: 팬텀 리드, 반복 불가능한 읽기 등)를 **DB 엔진이 내부적으로 방지**하도록 할 수 있습니다 . 특히 **Serializable(직렬화)** 수준은 모든 트랜잭션이 순차적으로 실행된 것과 같은 결과를 보장하여 대부분의 동시성 오류를 막아줍니다 .

  

PostgreSQL과 MySQL의 기본 격리 수준과 구현이 다르므로, 이를 이해하고 활용하는 것이 중요합니다:

• **PostgreSQL의 기본 격리 수준: Read Committed** – PostgreSQL은 기본적으로 Read Committed를 사용하며, 커밋된 데이터만 읽고 **각 쿼리마다 새로 스냅샷을 획득**합니다 . Read Committed에서는 **동일 트랜잭션 내에서도** 다른 쿼리를 실행할 때 이미 커밋된 다른 트랜잭션 결과를 볼 수 있습니다 . 예를 들어 트랜잭션 내 두 번의 SELECT 사이에 다른 트랜잭션이 커밋되었다면 두 SELECT 결과가 달라질 수 있습니다. 이 모드에서 한 트랜잭션이 데이터를 변경 중이면 다른 트랜잭션은 해당 행을 업데이트하려 할 때 그 트랜잭션이 끝날 때까지 기다렸다가 진행합니다 . 그러나 **갱신 분실(Lost Update)** 문제는 Read Committed alone으로 자동 방지되지 않을 수 있습니다. 예를 들어 두 트랜잭션이 같은 행을 읽고 수정하면, PostgreSQL에서는 두 번째 수정자가 처음 수정자의 커밋을 반영하여 **조건 재평가 후 업데이트를 시도**하지만 , 만약 WHERE 조건이 단순히 기본 키같이 계속 만족되는 조건이라면 두 번째 업데이트가 앞선 변경을 덮어쓸 수 있습니다. 이런 Lost Update는 PostgreSQL에서는 **애플리케이션이 명시적으로 잠금(SELECT FOR UPDATE)**을 걸거나, **격리 수준을 높여**야만 막을 수 있습니다.

• **PostgreSQL의 Repeatable Read와 Serializable** – PostgreSQL에서 Repeatable Read 이상으로 격리를 올리면 **동일 트랜잭션 동안 스냅샷을 고정**하여 팬텀 리드를 포함한 대부분의 이상 현상을 차단합니다 . 특히 PostgreSQL의 Repeatable Read는 실제로 **Serializable 수준에 가까운 스냅샷 격리**를 제공하여 팬텀 리드도 발생하지 않도록 구현되어 있습니다 (PG의 Repeatable Read는 **Snapshot Isolation**으로, 팬텀을 허용하지 않음). **Serializable** 모드는 그 위에 **추가적인 검증**을 통해 완전히 직렬화되는지 검사하며, 만약 직렬화 불가능한 상황 (예: 갱신 충돌이나 교차 갱신으로 인한 사이클)이 감지되면 **트랜잭션을 커밋 시 실패**시킵니다 . 예를 들어, 두 트랜잭션이 같은 행을 수정하려고 Serialiazable 모드로 실행하면, 둘 다 성공시키는 것이 직렬화 불가능하므로 한 쪽은 **“직렬화 불가 – 동시 업데이트”** 오류를 내고 롤백됩니다 . 이는 DB가 낙관적 검증을 수행해 충돌을 감지한 것으로 볼 수 있습니다. 따라서 Serializable로 실행하면 애플리케이션은 **충돌 시 재시도**를 해야 하지만, 그만큼 데이터 일관성은 자동으로 지켜집니다 .

• **MySQL(InnoDB)의 기본 격리 수준: Repeatable Read** – MySQL InnoDB는 기본이 Repeatable Read이며, 트랜잭션 시작 시점의 스냅샷을 사용하여 **모든 SELECT가 동일한 스냅샷을 보도록** 합니다. InnoDB의 Repeatable Read는 **넥스트 키 락(next-key lock)**이라는 기록+갭 잠금으로 일부 팬텀 리드를 막는 특징이 있습니다. 예를 들어 범위 조건으로 SELECT … FOR UPDATE를 하면 해당 범위에 속한 **없던 값에 대한 삽입(팬텀)을 다른 트랜잭션이 하지 못하게** 락을 겁니다. 이로써 팬텀 리드를 방지할 수 있습니다. 다만, 단순 SELECT만으로는 팬텀을 허용하므로, 팬텀까지 막으려면 명시적 잠금 읽기를 사용해야 합니다. MySQL의 Serializable 모드는 InnoDB에서는 Repeatable Read와 크게 다르지 않지만, MySQL 레벨에서 **모든 SELECT를 암묵적으로 FOR SHARE로 취급**하여 읽기도 공유 락을 거는 방식으로 구현됩니다. 그래서 MySQL에서 Serializable을 쓰면 읽기조차 락을 걸기 때문에 **동시성이 크게 저하**될 수 있습니다. 반면 PostgreSQL의 Serializable은 **낙관적 검증 방식**이라 읽기에 락을 걸지 않고도 직렬화 보장을 하는 차이가 있습니다 .

• **격리 수준을 활용한 실무 전략**: 일반 웹서비스에서는 대부분 기본 격리 수준(Read Committed in PG, Repeatable Read in MySQL)을 사용합니다. 그러나 **금융 거래처럼 엄격한 일관성**이 필요한 경우나, **복잡한 다중 단계 트랜잭션**에서 미묘한 동시성 버그가 우려될 경우 Serializable을 고려할 수 있습니다. Serializable로 실행하면 DB가 알아서 직렬화 여부를 검사하므로 개발자는 **낙관적 락과 유사하게** 충돌 시 재시도 코드를 두면 비교적 쉽게 안전성을 높일 수 있습니다 . 예를 들어 **은행 계좌 이체**의 트랜잭션들을 Serialiazable로 실행하면 이체 도중 다른 트랜잭션이 같은 계좌 잔액을 건드리는 경우 자동으로 한 쪽을 롤백시켜 이중 갱신을 막아줄 수 있습니다.

• **주의사항**: 격리 수준을 올리면 **교착상태나 롤백이 증가**할 수 있고, 성능에 영향이 있습니다. 따라서 **부분적으로만 격리 수준을 높이는 전략**도 고려됩니다. 특정 트랜잭션 블록에 대해서만 SET TRANSACTION ISOLATION LEVEL ...로 격리 수준을 높이는 것입니다. 예컨대, 결제 처리 트랜잭션만 Serializable로 수행하고 나머지는 기본 수준으로 하면, 중요한 일관성은 지키면서 대부분의 트랜잭션은 경량으로 유지할 수 있습니다. PostgreSQL과 MySQL 모두 세션 또는 트랜잭션 단위로 격리 수준을 변경하는 SQL을 제공합니다 (SET TRANSACTION ISOLATION LEVEL ... 구문) .

  

정리하면, **트랜잭션 격리 수준**은 동시성 제어를 위한 중요한 도구입니다. **낮은 격리**에서는 성능은 좋지만 애플리케이션이 직접 잠금이나 검증을 통해 정합성을 관리해야 하고, **높은 격리**에서는 DB가 많은 것을 보장해주지만 성능과 복잡도의 trade-off가 있습니다. 실무에서는 **가능한 기본 수준**을 유지하되, **문제가 되는 특정 상황에 한해 잠금 또는 격리수준 상향**을 적용하는 식으로 균형을 맞추는 경우가 많습니다 .

  

**분산 락과 멀티 인스턴스 환경 고려**

  

서비스가 **멀티 인스턴스**로 동작할 때 (예: 동일한 애플리케이션이 여러 대의 서버에서 구동), 동시성 문제는 더욱 복잡해질 수 있습니다. 각 인스턴스가 별도의 프로세스로 돌아가기 때문에 **프로세스 메모리나 쓰레드 락으로는 교차 제어가 불가능**합니다. 즉, 한 인스턴스에서 처리 중인 업무를 다른 인스턴스가 모른다면, 동일한 작업을 중복 수행하거나 같은 자원을 건드릴 위험이 있습니다. 이러한 환경에서는 **분산 락(distributed lock)**이나 **중앙 집중식 조정자**를 도입하여 인스턴스 간 조율을 해야 합니다.

  

**1. 데이터베이스를 이용한 분산 락**: 가장 간단한 방법은 **공유 데이터베이스를 락 저장소로 활용**하는 것입니다. PostgreSQL과 MySQL 모두 **사용자 정의 락** 기능을 제공합니다:

• **PostgreSQL Advisory Lock**: PostgreSQL는 **Advisory Lock**이라는 메커니즘을 제공하여 애플리케이션 수준에서 임의의 락을 걸 수 있습니다 . pg_advisory_lock(key) 함수를 호출하면 숫자 키에 대한 락을 획득하며, 이는 세션 또는 트랜잭션이 끝날 때까지 유지됩니다 . 예를 들어 SELECT pg_advisory_lock(12345);를 사용하면 키 12345에 대해 세션 락을 얻고, 다른 세션에서 동일 함수를 호출할 경우 **선행 세션이 락을 놓을 때까지 대기**합니다 . 이 락은 애플리케이션이任意로 지정한 키를 사용하므로, **특정 자원에 대한 전역 락**으로 활용할 수 있습니다. 트랜잭션 단위의 advisory lock도 가능하며 (pg_advisory_xact_lock), 보통 **멀티 인스턴스 작업 스케줄링**이나 **크리티컬 섹션 보호**에 사용됩니다. 예를 들어 하루에 한번 배치 작업을 여러 서버 중 한 곳에서만 실행하고 싶을 때, 모두 pg_try_advisory_lock(999)를 시도하게 하고 **성공한 한 인스턴스만 작업 진행**하도록 할 수 있습니다.

• **MySQL GET_LOCK**: MySQL은 GET_LOCK('name', timeout) 함수를 통해 **네임드 락**을 제공합니다. 지정한 이름(String)에 대한 락을 획득하며, 락은 세션이 종료되거나 RELEASE_LOCK 호출 시 해제됩니다 . 락 이름은 DB 서버 전역에서 유일하게 간주되므로, 하나의 세션이 "order_12345"라는 이름으로 락을 얻으면 다른 세션은 동일 이름에 대해 락을 얻을 수 없습니다 . GET_LOCK은 이미 해당 세션이 다른 락을 가지고 있어도 동시에 추가 락을 획득할 수 있으며 (하나의 세션이 여러 개의 이름 다른 락을 소유 가능 ), **timeout**을 두어 기다릴 시간도 지정할 수 있습니다. 반환값은 성공 시 1, 타임아웃 시 0이므로 이를 통해 락 획득 여부를 확인합니다 . 예를 들어, 결제 트랜잭션 처리 시 SELECT GET_LOCK('USER_123', 5);로 사용자 123에 대한 락을 걸면 동시에 같은 사용자에 대한 중복 결제를 하나의 DB에서 순차 처리하게 만들 수 있습니다. (5초 내에 못 얻으면 0을 리턴하여 처리 포기 혹은 재시도). GET_LOCK으로 얻은 락은 트랜잭션 커밋과 연동되지 않으므로, **명시적으로 해제**하거나 세션 종료 시까지 유지되는 점을 유의해야 합니다 .

  

이러한 DB 기반 분산 락은 **별도 인프라 없이 바로 사용**할 수 있다는 장점이 있습니다. 또한 **DB 장애 허용 범위 내**에서 락도 안전하게 유지됩니다. 다만 빈번한 분산 락 사용은 DB에 부하를 줄 수 있으므로, 너무 광범위하게 남발하기보다는 꼭 필요한 부분에 적용합니다. MySQL의 GET_LOCK은 내부적으로 **메타데이터 락**으로 구현되어 있어 수만 개 이상의 락을 사용할 경우 성능 저하나 데드락에 유의해야 합니다 . PostgreSQL의 advisory lock도 세션이나 tx별로 홀딩할 수 있는 락의 수와 지속 시간에 주의해야 합니다.

  

**2. Redis 등 외부 시스템 활용**: 더 큰 규모나 DB 부하를 피하고 싶을 때는 **Redis와 같은 인메모리 스토어**를 활용한 분산 락이 많이 사용됩니다. Redis는 단일 스레드로 동작하므로 자연스럽게 분산 락 용도로 활용되며, SETNX (SET if Not eXists) 명령이나 RedLock 알고리즘 등을 통해 구현합니다 . 앞의 재고 예시에서도, JackTT는 Redis SETNX 명령을 사용해 **분산 락 구현**을 언급했습니다 . SETNX lock_key value를 하면 해당 키가 없을 때만 설정이 성공하므로, 여러 클라이언트 중 하나만 lock_key를 성공적으로 세팅하게 되고 나머지는 실패합니다. 성공한 쪽이 업무를 진행한 후 키를 삭제(DEL)하거나, 키에 **만료 시간을 걸어서 자동 해제**되게 합니다 . 이러한 방식은 DB와 무관하게 동작하므로 애플리케이션 로직에 따라 **보다 유연하게 활용**할 수 있습니다. 예를 들어 **크론 작업 동시 실행 방지**, **다중 인스턴스에서 동일 사용자에 대한 작업 순서 보장** 등에 Redis 분산 락이 쓰입니다. 단, Redis를 별도로 운영해야 하고, Redis 자체의 가용성에 따른 락 신뢰성 이슈를 고려해야 합니다 (RedLock 알고리즘은 다중 노드 Redis를 통해 신뢰성을 높이는 기법이지만 복잡도가 있습니다).

  

**3. 멀티 인스턴스에서 중복 작업 방지**: 멀티 인스턴스 환경에서 자주 문제 되는 것이 **중복 요청 처리**입니다. 예를 들어 **사용자가 동일한 요청을 두 번 보냈을 때**, 두 개의 서버 인스턴스가 각기 이를 처리하여 **중복된 결과**를 만들어낼 수 있습니다. 이를 막으려면 **중앙에서 중복 여부를 판단**해야 합니다. 한 가지 방법은 **요청에 멱등 키(idempotency key)**를 두어 이미 처리된 키인지 DB나 캐시로 확인하는 것입니다 . 클라이언트에게 GUID/UUID 등을 발급해 해당 요청의 고유 ID로 사용하게 하고, 서버에서는 이 GUID를 **별도 테이블**(예: processed_requests)이나 **캐시(예: Redis Set)**에 기록해둡니다 . 새로운 요청이 들어올 때 같은 GUID가 기록되어 있다면 **중복 요청으로 간주하고 처리하지 않거나 거부**합니다. 이렇게 하면 100번을 눌러도 최초 1번만 효과가 있고 이후에는 무시됩니다 . 예를 들어 Spring 기반 서비스에서 processedGuids 집합(Set)으로 GUID를 관리하고, synchronized 블록으로 체크하는 예제가 있지만 이는 단일 인스턴스에 국한되므로, 실제 멀티 인스턴스 환경에선 **동일한 로직을 DB나 Redis로 구현**해야 함을 강조하고 있습니다 .

  

**4. 다중 DB 인스턴스 고려**: 일반적인 소~중규모 서비스는 하나의 DB (또는 마스터-슬레이브 구조)만 사용하지만, 만약 **멀티 마스터나 샤딩** 등으로 **DB가 분산**되어 있다면 동시성 제어는 더욱 어려워집니다. 예를 들어 MySQL Galera Cluster 같은 멀티마스터에서는 각 노드에서 동일 자원에 대한 락이 전달/동기화되므로 레이턴시가 증가하고, 자칫하면 **분산 데드락**이 생길 수 있습니다. 이런 환경에서는 가급적 한 노드(마스터)에서만 쓰기 락을 처리하도록 아키텍처를 구성하거나, 데이터 파티셔닝을 통해 **서로 다른 분할에는 독립적 작업이 이루어지게** 하는 전략이 필요합니다. 이러한 주제는 고도화된 분산DB 설계 영역이므로 여기서는 원칙만 언급합니다: **멀티 인스턴스 환경에서는 일관성 유지를 위해 중앙 조율 시스템을 활용**해야 하며, 데이터베이스 락은 그 DB 범위 내에서만 유효하다는 점을 기억해야 합니다.

  

**Upsert 및 중복 데이터 처리 (INSERT 충돌 해결 전략)**

  

**Upsert**란 **INSERT와 UPDATE를 결합한** 개념으로, **데이터가 없으면 삽입하고 이미 존재하면 업데이트**하는 원자적 연산을 가리킵니다 . 이는 동시성 환경에서 **중복 데이터** 발생을 방지하고, 별도의 존재여부 검사 없이 한 번의 쿼리로 처리가 가능하기 때문에 널리 사용됩니다. 작은 서비스에서 흔히 일어나는 **중복 레코드 문제** (예: 동일 키로 두 번 INSERT)가 있을 때, upsert를 사용하면 한 트랜잭션에서 자동으로 처리되므로 데이터 정합성을 지킬 수 있습니다.

  

**PostgreSQL – INSERT … ON CONFLICT**: PostgreSQL은 9.5 버전부터 INSERT ... ON CONFLICT 구문을 제공하여 upsert를 지원합니다. 사용법은 INSERT ... ON CONFLICT [conflict_target] DO [UPDATE|NOTHING] 형식으로, 충돌(기본키 또는 지정한 유니크 키 충돌)이 발생하면 UPDATE를 수행하거나 그냥 무시하도록 지정합니다. 예를 들어 사용자 테이블에 고유 키가 email인 경우, 중복 가입을 막기 위해 다음과 같이 쓸 수 있습니다:
```
INSERT INTO users(email, name)
VALUES ('user@example.com', '홍길동')
ON CONFLICT (email)
DO NOTHING;
```
이 쿼리는 해당 이메일이 없으면 새로운 유저로 INSERT 하고, 이미 존재하면 아무 변경도 하지 않습니다. 만약 존재하면 INSERT가 스킵되므로 **중복된 데이터가 생성되지 않습니다.** DO NOTHING 대신 DO UPDATE SET ...을 하면 충돌시 특정 컬럼들을 업데이트할 수도 있습니다. **INSERT…ON CONFLICT**는 하나의 SQL문 내에서 삽입 또는 갱신을 **원자적으로 처리**하므로, 응용단에서 SELECT로 존재 여부를 확인하고 UPDATE/INSERT를 분리 수행하는 것에 비해 **데이터 일관성과 성능** 면에서 우수합니다 . 두 트랜잭션이 같은 키로 동시 upsert를 시도해도, 내부적으로 락 경쟁을 통해 한 쪽은 INSERT하고 다른 쪽은 그 결과를 보고 UPDATE하거나 (혹은 DO NOTHING의 경우 아무것도 하지 않고) 끝나게 됩니다. 결과적으로 둘 이상의 트랜잭션이 동시에 실행되어도 **최종적으로 딱 하나의 레코드만 존재**하게 됩니다.

  

**MySQL – INSERT … ON DUPLICATE KEY UPDATE / REPLACE**: MySQL은 upsert를 위해 오래전부터 INSERT ... ON DUPLICATE KEY UPDATE 구문을 지원해왔습니다. 사용법은 PostgreSQL과 유사하게 INSERT문 뒤에 충돌 발생 시 수행할 UPDATE 절을 명시합니다. 예를 들어, 기본 키 또는 UNIQUE 제약 조건 위배 시 특정 컬럼을 증가시키는 쿼리는 다음과 같습니다:

```
INSERT INTO page_counts (url, count)
VALUES ('/index.html', 1)
ON DUPLICATE KEY UPDATE count = count + 1;
```

이 경우 최초에는 새로운 url로 삽입하고, 두 번째부터는 해당 url 레코드의 count를 1씩 증가시키게 됩니다. MySQL 문서에 따르면, ON DUPLICATE KEY UPDATE 절이 있고 INSERT하려는 값이 UNIQUE/PK 충돌을 일으킬 때 **기존 행에 대한 UPDATE가 발생**한다고 명시되어 있습니다 . 실제로 내부적으로는 실패 대신 UPDATE로 분기하며, LAST_INSERT_ID 등의 동작이 약간 특이하지만 개념적으로 **“없는 경우 INSERT, 있는 경우 UPDATE”**와 같습니다 . ON DUPLICATE KEY 구문을 사용할 때 주의할 점은, 대상 테이블에 다중 UNIQUE 인덱스가 있을 경우 논리가 복잡해질 수 있다는 것입니다 . 또한 MySQL에서는 REPLACE INTO라는 별도의 구문도 있는데, 이것은 “키 충돌 시 기존 행을 삭제하고 새 행으로 교체”하는 방식이라 업데이트와는 다소 다릅니다. REPLACE는 삭제 후 삽입으로 동작하기 때문에 **삭제 트리거가 발동**된다거나 **AUTO_INCREMENT가 초기화**되는 등 부작용이 있을 수 있으므로, 일반적인 upsert 용도로는 ON DUPLICATE KEY UPDATE가 선호됩니다.

  

**중복 요청/데이터 처리와 Upsert**: 중복 요청을 처리할 때 upsert를 활용하면 유용한 패턴들이 있습니다.

• **멱등 요청 처리**: 예를 들어 사용자가 동일 결제 요청을 두 번 보내는 상황을 생각해봅시다. 우리 시스템에서 각 결제 요청에 request_id라는 고유 식별자를 부여하고, 이 필드를 UNIQUE로 하는 테이블에 결제 정보를 INSERT하도록 합니다. 쿼리를 ON CONFLICT DO NOTHING (PG) 혹은 ON DUPLICATE KEY UPDATE ... (MySQL)로 작성해두면 동일 request_id로 두 번 INSERT해도 하나는 성공하고 하나는 아무 효과 없이 지나가게できます. 실제로 **INSERT…ON CONFLICT DO NOTHING**은 **멱등(idempotent)**한 INSERT 시나리오에 자주 쓰이며, **이미 처리된 요청을 무시**하는 로직을 간단히 구현해줍니다. 이렇게 하면 이중 결제를 예방할 수 있고, 애플리케이션에서는 두 번째 시도에 대해 “이미 처리된 요청”이라고 응답할 수 있습니다. (혹은 첫 번째와 동일한 결과를 리턴하여 사용자에겐 두 번 눌러도 결과가 같도록 한다.)

• **중복 데이터 삽입 방지**: upsert를 쓰지 않아도, UNIQUE 제약 조건을 걸어놓으면 중복 시도 시 오류가 발생하여 중복 삽입은 막을 수 있습니다. 그러나 단순 UNIQUE 제약은 **에러를 발생**시키므로 애플리케이션에서 예외를 처리해야 하고, 사용자 경험 측면에서 별로 좋지 않을 수 있습니다. 대신 upsert를 쓰면 에러 없이 처리되므로 **개발 생산성과 UX** 측면에서 이점이 있습니다. 예를 들어, 어떤 예약 시스템에서 동일한 좌석에 대한 이중 예약을 막고 싶다면 좌석에 UNIQUE 키를 걸고 INSERT할 때 ON CONFLICT DO NOTHING을 사용하면 됩니다. 첫 번째 INSERT가 좌석을 선점하고, 두 번째 INSERT는 DO NOTHING에 의해 영향받는 행이 0이어서 트랜잭션을 통해 알 수 있습니다. 애플리케이션은 이를 감지해 “이미 예약된 좌석”이라고 알려주면 됩니다.

• **경합 상황에서의 Upsert 동작**: 두 트랜잭션이 동시에 동일한 키로 upsert를 날리면 어떻게 될까요? 이를테면 재고가 없는 상품에 대해 “재고 1로 추가” upsert를 두 군데서 동시에 실행하면, 하나는 INSERT를 할 것이고 다른 하나는 처음 것과 충돌하여 UPDATE 경로를 타게 됩니다. **PostgreSQL**의 경우 내부적으로 충돌 감지를 위해 **단일 row-level 락**을 사용하므로, 동시성 제어가 자동으로 이뤄집니다. 하나가 그 키에 대해 INSERT 락을 선점하면 다른 하나는 대기했다가, 첫 트랜잭션 커밋 후 해당 행이 생긴 것을 보고 UPDATE를 수행합니다 . **MySQL**도 마찬가지로, 첫 번째가 삽입하고 두 번째는 동일 키 충돌을 만나 바로 그 행을 업데이트합니다 . 이때 MySQL에서는 두 번째 연산의 결과 ROW_COUNT()가 2로 반환되는데 (기존 행 업데이트 시 2로 표시) 이를 통해 업데이트되었음을 알 수 있습니다 .

  

Upsert는 **데이터 일관성과 성능** 두 마리 토끼를 잡는 좋은 수단입니다. 다만 남용할 경우 **업데이트 로직이 복잡해지고** 예기치 않은 갱신이 이루어질 수 있으므로, 비즈니스 로직상 명확히 “없으면 넣고 있으면 갱신”이 맞는 경우에만 사용해야 합니다. 또한 upsert로 인해 업데이트가 일어날 때와 삽입이 일어날 때의 **트리거 동작 차이** 등도 염두에 두어야 합니다. 예컨대, MySQL에서 ON DUPLICATE KEY UPDATE는 INSERT일 때와 UPDATE일 때에 각각 다르게 트리거가 호출될 수 있고, PostgreSQL에서도 EXCLUDED 테이블을 사용한 UPDATE에 의해 일부 컬럼은 새 값으로 대체되고 일부는 유지되는 등 로직이 복잡해질 수 있습니다. 따라서 중요한 데이터에 대해 upsert를 쓸 땐 **충분한 테스트**와 **문서 확인**이 필요합니다.

---

以上와 같이, **데이터베이스 동시성 문제를 예방하거나 제어**하기 위한 다양한 접근 방법을 살펴보았습니다. 실제 현업에서는 이들 전략을 **상황에 맞게 조합**하여 사용합니다. 예를 들어 **낙관적 잠금으로 대부분 처리**하되 간혹 충돌이 잦은 특정 경우 **행 잠금으로 전환**하거나, **DB 락과 Redis 락을 함께 활용**하여 로우 수준과 전역 수준의 동시성 관리를 병행할 수도 있습니다 . 중요한 것은 각각의 기법이 **어떤 문제를 해결해주며, 어떤 한계와 부하를 수반하는지** 이해하는 것입니다.

  

마지막으로, 동시성 문제는 언제나 완벽히 사라지기보다는 **철저한 대비와 테스트로 관리**되는 것임을 명심해야 합니다. 데이터 정합성과 무결성은 서비스 신뢰성과 직결되므로, 사전에 충분한 시나리오를 고려해 안전장치를 마련하고, 운영 중에도 모니터링과 튜닝을 통해 동시성 이슈를 지속적으로 다뤄나가야 할 것입니다.

  

**참고 자료:** PostgreSQL 공식 문서 , MySQL 공식 문서 , 개발자 블로그 (동시 구매 처리 예시) , 기타 실무 경험 블로그 등.
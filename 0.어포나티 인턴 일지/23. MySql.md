# mysql 기술적 특징

- [[23.1. InnoDB]]스토리지 엔진의 도입으로 트랜잭션 데이터베이스 기능 구현
- RDBMS의 기본 속성과 작동 방식 포함
- [[23.2. optimizer]] 관련 기능 제공

성능 최적화를 위해서는 올바른 설정 파일, 파라미터 튜닝이 중요

# MySQL 설정 및 파라미터 튜닝
## 설정 파일 기본 구조
1. 사용자 관리 파일
2. 시스템 관리 파일
3. 서버 구동 시 mysql 설정 파일을 메모리에 로드함

## 파라미터 변경 메커니즘
- 운영중에는 SET 명령어로 글로벌 변수 값 변경 가능
- 메모리상의 변경은 서버 재시작 시 사라짐 -> 설정 파일의 저장이 필요함
- SET PERSIST 명령어로 변경사항을 영구 저장 가능

## 중요 파라미터
- **innodb_buffer_pool_size**: 가장 중요한 파라미터로, MySQL이 사용하는 캐시 메모리 크기 설정
- 디스크에서 읽지 않고도 데이터를 메모리에서 바로 조회할 수 있게 해주는 **InnoDB 버퍼 풀의 크기**
- 일반적으로 전체 메모리의 75-80% 정도로 설정하는 것이 권장됨
- 해시 인덱스, 체인지 버퍼 등의 구조적 파라미터
- 플러시 관련 설정

## 메모리 관리 원리
- RDBMS는 디스크에 저장된 데이터를 메모리로 로드하여 작업
- 디스크에서 데이터를 반복적으로 읽는 것보다 메모리에 캐싱하는 것이 성능상 유리
- ==메모리에 올라간 데이터가 변경되면 나중에 디스크와 동기화하는 작업이 필요==
- ==버퍼 히트 이슈==: 데이터가 메모리에 있는지 확인하는 과정이 성능에 큰 영향

## 로깅 설정
- 로그 관련 파라미터를 글로벌 하게 설정
- 슬로우 쿼리 로그: 특정 시간 이상 수행되는 쿼리를 기록하는 설정이 가능함
### 슬로우 쿼리 로그
- **성능 튜닝:** 데이터베이스의 성능을 향상시키기 위해 느린 쿼리를 식별하고 최적화할 때 사용된다.
- **문제 진단:** 어떤 쿼리가 성능 이슈를 일으키는지 파악하여 해결하는데 도움이 된다.
- **시스템 감지:** 데이터베이스 시스템을 지속적으로 감시하여 성능 저하를 미리 감지할 수 있다.

# MySQL 아키텍처 및 업그레이드 방법

- LTS(Long Term Support) 버전으로 업그레이드하는 두 가지 주요 방법: 인플레이스 업그레이드와 로지컬 업그레이드
- 인플레이스 업그레이드는 데이터 파일은 그대로 두고 엔진만 교체하는 방식
- 로지컬 업그레이드는 데이터를 웹으로 내리는 방식과 레플리케이션을 통한 방식으로 나뉨
- 운영 환경에서는 주로 레플리케이션을 통한 방식이 다운타임을 최소화하기 위해 사용됨

### MySQL 엔진 아키텍처

- MySQL 아키텍처는 크게 두 부분으로 구성: MySQL 엔진 영역과 스토리지 영역
- MySQL 엔진은 클라이언트 연결 관리, 쿼리 최적화, 실행 계획 생성을 담당하는 옵티마이저 역할
- 쿼리 실행 엔진은 사용자 요청을 받아 처리하고 실행 계획 생성
- MySQL 8.0에서는 이전 버전(5.7)에 있던 쿼리 캐시(리절트 캐시)가 제거됨

### 스토리지 엔진

- 대부분의 환경에서 InnoDB 스토리지 엔진을 사용
- 스토리지 엔진은 데이터 저장, 검색, 쓰기 등 I/O 작업을 담당

### ==MySQL 프로세스와 스레드==

- MySQL은 프로세스 기반으로 동작
- 두 가지 유형의 스레드: 포그라운드 스레드와 백그라운드 스레드
- 포그라운드 스레드는 사용자 연결마다 하나씩 생성되어 클라이언트 요청 처리
- 백그라운드 스레드는 데드락 감지 등 시스템 유지 작업 수행

### 연결 관리 및 스레드 풀링

- 리소스 효율성을 위해 연결 풀링([[23.3. connection pooling]]) 사용 권장
- 미들웨어 단에서 연결 풀링을 제공하거나 서버 사이드 풀링 사용 가능
- 포그라운드 스레드는 연결이 끊어진 후에도 일정 시간 캐시되어 재사용됨으로써 리소스 절약

![[스크린샷 2025-06-08 오후 1.19.52.png]]

# MySQL 내부 구조 및 성능 최적화 교육
## ==메모리 관리==

- 메모리는 세션별로 할당되며, 세션 수가 증가하면 메모리 사용량도 비례하여 증가
- 메모리 영역은 버퍼, 페이지 클리너, 퍼즈 등 다양한 용도로 사용됨
- 세션이 과도하게 많아지면 시스템 메모리를 모두 소비할 수 있어 적절한 설정이 중요
- 캠프 영역은 글로벌하게 제한(캡)을 설정하는 방식 사용

## 스토리지 엔진

- MySQL은 InnoDB 엔진을 사용하여 트랜잭션 처리
- 버퍼 풀을 통해 데이터와 인덱스 페이지를 캐싱하여 빠른 처리 지원
- ==Adaptive hash index와 change buffer가 성능 향상에 기여==
- 로그 시스템을 통해 데이터 일관성 유지
	[[23.4.  storageEngine]]
## 데이터 저장 및 인덱싱

- MySQL은 "Clustered by Primary Key" 방식으로 데이터 저장
- ==모든 데이터는 기본키(PK) 순서대로 정렬되어 저장됨==
- 세컨더리 인덱스는 데이터 페이지 주소가 아닌 ==PK 값을 참조==
- 모든 데이터 접근은 결국 PK를 통해 이루어짐

## 트랜잭션 및 동시성 제어

- MySQL은 ==[[23.5. MVCC]](Multi-Version Concurrency Control)== 방식 사용
- ==데이터 변경 시 즉시 디스크에 쓰지 않고 로그를 활용하여 성능 최적화==
- 일반적으로 데이터는 바로 저장되지 않고 일단 메모리(buffer에 저장을 함) -> 변경된 log를 기록함으로써 추후에 버퍼가 가득 차거나, 트랜잭션 커밋, 혹은 > **flush**(메모리에 있는 내용을 디스크에 강제 저장) 하는 작업을 요청 시 디스크에 로그에 맞게 데이터를 저장하여 최적화 함
- ACID 속성을 보장하면서도 성능을 유지

## ==캐싱 전략==

- 버퍼 풀에서 자주 사용되는 데이터를 캐싱하여 디스크 I/O 최소화
- 에이징 알고리즘을 통해 자주 사용되는 데이터를 메모리에 유지
- 체인지 버퍼를 활용하여 디스크 읽기 작업 지연 및 최적화
- 최신 버전(8.4)에서는 체인지 버퍼 관련 설정이 변경됨

![[스크린샷 2025-06-08 오후 1.22.20.png]]
# MySQL 데이터베이스 성능 최적화 기술 소개

## 데이터 버퍼링 및 페이지 관리

- MySQL은 16K 페이지 크기를 사용하지만 OS 레벨에서는 더 작은 페이지를 사용
- 이로 인해 데이터가 디스크로 내려갈 때 불일치가 발생하여 데이터 유실 가능성 존재
- [[23.6. 더블 라이트 버퍼(Double Write Buffer)]]를 통해 데이터 일관성을 보장
- 체크포인트 작업 시 더티 페이지(변경된 데이터)가 디스크로 안전하게 내려가도록 함

## 인덱싱 전략

- 어댑티브 해시 인덱스(Adaptive Hash Index)는 MySQL의 특별한 기능
- 세컨더리 인덱스는 일반적으로 두 번의 검색 과정이 필요함
- 어댑티브 해시 인덱스를 통해 데이터를 더 빠르게 찾을 수 있지만 모든 워크로드에 효율적이지는 않음
- 워크로드 특성에 따라 활성화 여부를 결정해야 함

## [[23.7. 메모리 관리 및 임시 테이블]]

- 쿼리 실행 중 사용되는 내부 임시 테이블(Internal Temporary Table) 영역의 중요성
- 버퍼 풀 내에서 임시 테이블 영역이 적절히 설정되어야 함
- 임시 테이블 크기가 메모리 한계를 초과하면 디스크 사용으로 인한 성능 저하 발생
- 버전 업그레이드(5.x에서 8.x)에 따라 임시 테이블 관련 메모리 관리 방식 변화

## 로깅 시스템

- 세 가지 주요 로그 유형: 에러 로그, 제너럴 로그, 슬로우 쿼리 로그
- 에러 로그: 시스템 오류 및 이벤트 기록
- 제너럴 로그: 모든 SQL 쿼리 기록 (일반적으로 필요한 경우에만 활성화)
- 슬로우 쿼리 로그: 지정된 시간(예: 1초) 이상 소요되는 쿼리 식별용
- 슬로우 쿼리 로그는 성능 튜닝을 위한 중요 도구

# MySQL 트랜잭션과 락킹 메커니즘 개요

## 트랜잭션 기본 개념

트랜잭션은 논리적 작업 단위로, 여러 SQL이 하나의 트랜잭션으로 묶여 수행됩니다. 트랜잭션은 ACID(원자성, 일관성, 격리성, 내구성) 특성을 충족해야 하며, 이를 통해 데이터 무결성이 보장됩니다.

## MySQL의 락 종류

- 글로벌 락: 전체 데이터베이스에 대한 락
- 테이블 락: 특정 테이블에 대한 락
- 로우 락: 특정 행(row)에만 락을 걸어 동시성을 높임

MySQL은 특히 '넥스트키 락(next-key lock)'이라는 특별한 락킹 메커니즘을 사용합니다. 이는 레코드 락(record lock)과 갭 락(gap lock)을 결합한 형태입니다.

## [[23.8. 갭 락(Gap Lock)]]의 중요성

갭 락은 인덱스 레코드 사이의 간격에 락을 거는 방식입니다. 예를 들어 인덱스 값이 1과 10인 레코드가 있다면, 1부터 10 사이의 모든 가능한 값에 락을 걸어 새로운 레코드 삽입을 방지합니다.

## [[23.9. 격리 수준(Isolation Level)]]

MySQL은 기본적으로 REPEATABLE READ 격리 수준을 사용합니다. 이는 다른 DBMS와 달리 넥스트키 락을 통해 팬텀 리드(phantom read) 현상을 방지하는 특징이 있습니다.

팬텀 리드는 트랜잭션 내에서 동일한 쿼리를 두 번 실행했을 때 다른 결과가 나오는 현상을 말하며, MySQL의 넥스트키 락 구조는 이러한 문제를 효과적으로 해결합니다.

## 동시성 제어

여러 사용자가 동시에 같은 데이터에 접근할 때 발생하는 문제를 해결하기 위해 MySQL은 독특한 락킹 전략을 사용합니다. 이를 통해 데이터 일관성을 유지하면서도 적절한 수준의 동시성을 제공합니다.

# MySQL 옵티마이저 및 데이터베이스 관리 개요

## 옵티마이저 및 실행 계획

SQL이 입력되면 구문 검사와 관련 객체 확인을 수행합니다. 옵티마이저는 가장 비용이 낮은 실행 계획을 결정하는데, 인덱스 읽기는 디스크 읽기보다 비용이 낮게 설정되어 있습니다(예: 인덱스 읽기 비용 1, 디스크 읽기 비용 10). 힌트를 통해 옵티마이저의 동작을 제어할 수 있으며, 이는 스위치를 통해 글로벌 또는 세션 레벨에서 설정 가능합니다.

## 인덱스 활용 전략

정렬(Sort) 작업은 크게 두 가지 방식으로 수행됩니다:

- 정렬된 인덱스 활용하기
- 정렬된 인덱스를 사용할 수 없을 때 데이터를 가져와서 정렬하기

가장 효율적인 방법은 적절히 정렬된 인덱스를 직접 사용하는 것입니다. GROUP BY 작업도 마찬가지로 적절한 인덱스 활용이 중요합니다.

## 모니터링 및 성능 분석

MySQL 내에서 통계 정보와 성능 관련 데이터를 모니터링할 수 있습니다. EXPLAIN 명령어를 사용하면 SQL 쿼리의 실행 계획을 확인할 수 있으며, 이는 통계 정보 기반의 예상 실행 계획과 실제 수행 결과를 비교하는 데 유용합니다. EXPLAIN은 쿼리 실행에 소요되는 비용 정보도 제공합니다.

## 백업 및 복구 전략

백업은 논리적(Logical) 백업과 물리적(Physical) 백업 두 가지 방식이 있습니다:

- 논리적 백업: SQL 덤프 형태
- 물리적 백업: 데이터 파일 자체를 복사

MySQL Enterprise Backup을 사용하면 장애나 이벤트에 대비한 복제본을 생성할 수 있습니다. 이 복제본은 장애 발생 시 복구에 활용됩니다.



## 서브쿼리

- sql문 안에 있는 또 다른 sql문을 말함

사용 가능한 곳
1. Select
2. From
3. Where
4. Having
5. Order by
6. DML
*group by에서는 사용 불가능*

### 종류
#### 동작
1. un-correlated(비연관) 서브쿼리
	- 서브쿼리가 메인쿼리 컬럼을 가지고 있지 않은 형태
	- 서브쿼리의 결과 값을 메인쿼리에 제공하기 위한 목적
2. correlated(연관) 서브쿼리
	- 서브쿼리가 메인쿼리 컬럼을 가지고 있는 형태
	- 메인쿼리의 값이 서브쿼리에서 조건이 맞는지 확인 할때

#### 위치
1. 스칼라 서브쿼리(select): 서브쿼리 결과를 하나의 컬럼처럼 사용
2. 인라인뷰(from): 서브쿼리 결과를 하나의 테이블처럼 사용
3. where절 서브쿼리: 비교 상수 자리에 값을 전달하기 위한 목적

#### where 서브쿼리 종류

1. 단일행 서브쿼리: 1개의 행이 리턴되는 형태
	![[Pasted image 20250219142737.png]]
	![[Pasted image 20250219142657.png]]
2. 다중행 서브쿼리
	![[Pasted image 20250219142802.png]]
	![[Pasted image 20250219142821.png]]
3. 다중컬럼 서브쿼리
	![[Pasted image 20250219143146.png]]
	- 비교시 in을 사용
4. 상호연관 서브쿼리 - 메인쿼리와 서브쿼리의 비교를 수행
	![[Pasted image 20250219143320.png]]
* 상호연관 서브쿼리 연산 순서 
1) 메인쿼리 테이블 READ 
2) 메인쿼리 WHERE절 확인(SAL 확인) 
3) 서브쿼리 테이블 READ 
4) 서브쿼리 WHERE절 확인(다시 E1.DEPTNO 요구) 
5) E1.DEPTNO 값을 서브쿼리의 DEPTNO 컬럼과 비교하여 조건절 완성 
6) 위 조건에 성립하는 행의 그룹연산 결과 확인(AVG(SAL)) 
7) 위 결과를 메인쿼리에 전달하여 해당 조건을 만족하는 행만 추출 
	※ 상호연관 서브쿼리 사용 시 GROUP BY 생략 가능

#### 인라인 뷰
- 쿼리 안의 뷰의 형태로 테이블처럼 조회할 데이터를 정의하기 위해 사용
- 테이블명이 존재하지 않기 때문에 다른 테이블과 조인 시 반드시 테이블 별칭 명시 (단독으로 사용하는 경우 불필요) 
- WHERE절 서브쿼리와 다르게 ==서브쿼리 결과를 메인 쿼리의 어느 절에서도 사용할 수 있음 ==
- 인라인뷰의 결과와 메인쿼리 테이블과 조인할 목적으로 주로 사용 
- 모든 연산자 사용 가능
#### 스칼라 서브쿼리
- SELECT절에 사용하는 쿼리로, 마치 하나의 컬럼처럼 표현하기 위해 사용 (단, 하나의 출력 대상만 표현 가능)
- 각 행마다 스칼라 서브쿼리 결과가 하나여야 함(단일행 서브쿼리 형태)
- 조인의 대체 연산
- 스칼라 서브쿼리를 사용한 조인 처리 시 OUTER JOIN이 기본(값이 없더라도 생략되지 않고 NULL로 출력됨)

#### 서브 쿼리 주의 사항 
- 특별한 경우(TOP-N 분석 등)을 제외하고는 서브 쿼리절에 ORDER BY절을 사용 불가
- 단일 행 서브쿼리와 다중 행 서브쿼리에 따라 연산자의 선택이 중요

#### 집합 연산자
 - select 문 결과를 하나의 집합으로 간주
 - 두 집합의 컬럼이 동일하게 구성되어야 함(데이터 타입과 순서 일치가 필요)

##### 합집합
- union
	1. 중복 데이터는 한 번 출력
	2. 내부적으로 중복 데이터 제거를 위한 정렬 수행
	3. 중복 데이터 없으면 아래의 연산자를 사용하는게 좋음
- union all
	1. 그냥 모든 데이터 전체 출력

##### 교집합
- intersect
	1. 두 집합의 공통 행 출력

##### 차집합
- minus
	1. 말 그대로 차집합

##### 주의 사항
- 개별 select문에 order by 전달 불가능
- 잘 생각해보면 두 집합의 컬럼 수, 순서, 데이터 타입이 일치해야하는데 order by 사용시 그 규칙이 깨짐

#### 그룹함수
- 숫자 함수중 여러 값을 전달 -> 요약 값을 출력하는 다중행 함수
- group by 절에 의해 연산 결과 리턴
- null은 무시하고 연산 -> 말 그대로 없는 취급 함

##### count
- * 또는 단 하나의 컬럼만 전달 가능 
- * 사용 시 모든 컬럼의 값이 널일 때만 COUNT 제외
##### sum
##### avg
- NULL을 제외한 대상의 평균을 리턴
##### min/max
##### variance/stddev

#### group by function
- 여러 GROUP BY결과를 동시에 출력(합집합)

##### grouping sets(A, B, ....)
- a별, b별 그룹 연산 결과를 출력
![[Pasted image 20250224171200.png]]
즉, 30 CLERK 인 값이 있을때 DEPTNO와 JOB에서 한 번씩 결과에 집계가 된다
##### ROLLUP(A, B)
- A, (A, B) 로 그룹연산 결과 출력
- 나열 대상의 순서가 중요
- 전체 총 계도 출력함
##### CUBE(A, B)
- A, B, (A, B) 그룹으로 연산 결과 출력

#### [[3.1. window 함수]]
- 서로 다른 행의 비교나 연산을 위해 만든 함수
- group by 사용하지 않고 그룹 연산 가능

#### RANK(순위) 함수
##### RANK WITHIN GROUP
- 특정 값의 대한 순위 확인
```
SELECT RANK(a) WITHIN GROUP A
```
A에서 값 a의 순위

##### RANK() OVER(), DENSE_RANK(), ROW_NUMBER()
96


#### 비율 함수
##### RATIO_TO_REPORT
- 각 값의 비율 리턴
- order by 사용 불가능
- 0.333, 0.333, 0.333

##### CUME_DIST
- 각 행의 누적 비율
- order by 필수, 누적 비율의 순서 정할 수 있음
- ex) 0.333, 0.666, 1

##### ERCENT_RANK 
- PERCENTILE(분위수) 출력 
- 전체 COUNT중 상대적 위치 출력(0~1 범위 내) 
- ORDERY BY 필수
- 0, 0.5, 1

#### [[3.2. TOP N 쿼리]]

#### 계층형 질의
- 하나의 테이블 내 각 행끼리 관계를 가질 때, 연결고리를 통해 행과 행 사이의 계층(depth)을 표현
- PRIOR의 위치에 따라 연결하는 데이터가 달라짐
![[Pasted image 20250224182528.png]]

![[Pasted image 20250224182731.png]]
0001 -> 1000   -> 1001 
			-> 1002
	 -> 1003   -> 1004 
		    -> 1005
	 -> 1006   -> 1007   -> 1008
				    -> 1009
				    -> 1010
				    -> 1011
계층형 질의 가상 컬럼 
1. LEVEL : 각 DEPTH를 표현(시작점부터 1) 
2. CONNECT_BY_ISLEAF : LEAF NODE(최하위노드) 여부(참:1, 거짓:0)

계층형 질의 가상 컬럼 - ==예시 함 작성해보기==
1. CONNECT_BY_ROOT 컬럼명 : 루트노드의 해당하는 컬럼값 
2. SYS_CONNECT_BY_PATH(컬럼, 구분자) : 이어지는 경로 출력 
3. ORDER SIBLINGS BY 컬럼 : 같은 LEVEL일 경우 정렬 수행 
4. CONNECT_BY_ISCYCLE : 계층형 쿼리의 결과에서 순환이 발생했는지 여부

### pivot and unpivot
#### 데이터 구조
1. long date
	- 하나의 속성이 하나의 컬럼으로 정의 되어 값이 쌓이는 구조
	- 다른 테이블과의 조인 연산이 가능
	- 일반적으로 api개발할 때 사용한 구조
![[Pasted image 20250225213227.png]]
2. wide data
	- 행과 컬럼에 유의미한 정보 전달을 목적으로 작성하는 교차 표
	- rdbms에 값이 추가될 때 마다 컬럼이 추가돼야 해서 비효율적
	- join 불가능
	- 데이터 요약이 목적
![[Pasted image 20250225214012.png]]
데이터 변경 구조
pivot: long -> wide

![[Pasted image 20250225214004.png]]

unpivot: wide -> long

● ==PIVOT ==
- 교차표를 만드는 기능 
- STACK 컬럼, UNSTACK 컬럼, VALUE 컬럼의 정의가 중요! 
- FROM절에 STACK, UNSTACK, VALUE 컬럼명만 정의 필요(필요 시 서브쿼리 사용하여 필요 컬럼 제한)
- PIVOT 절에 UNSTACK, VALUE 컬럼명 정의 
- PIVOT 절 IN 연산자에 UNSTACK 컬럼 값을 정의 
- FROM절에 선언된 컬럼 중 PIVOT절에서 선언한 VALUE컬럼, UNSTACK컬럼을 제외한 모든 컬럼은 STACK컬럼이 됨

![[Pasted image 20250225221207.png]]

![[Pasted image 20250225221344.png]]
다음과 같이 EMP라는 테이블 명만 작성하면, 모든 컬럼이 적용이 되는데 value와 unstack 부분이 지정된 두 컬럼 이외는 모두 stack처리가 됨

● UNPIVOT 
- WIDE 데이터를 LONG 데이터로 변경하는 문법 
- STACK컬럼 : 이미 UNSTACK되어 있는 여러 컬럼을 하나의 컬럼으로 STACK시 새로 만들 컬럼이름 (사용자 정의)
- VALUE컬럼 : 교차표에서 셀 자리(VALUE)값을 하나의 컬럼으로 표현하고자 할 때 새로 만들 컬럼명 (사용자 정의) 
- 값1, 값2... : 실제 UNSTACK 되어 있는 컬럼 이름들

![[Pasted image 20250225222458.png]]

![[Pasted image 20250225223102.png]]
### [[3.3. 정규 표현식]]



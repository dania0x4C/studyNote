## 서브쿼리

- sql문 안에 있는 또 다른 sql문을 말함

사용 가능한 곳
1. Select
2. From
3. Where
4. Having
5. Order by
6. DML
*group by에서는 사용 불가능*

### 종류
#### 동작
1. un-correlated(비연관) 서브쿼리
	- 서브쿼리가 메인쿼리 컬럼을 가지고 있지 않은 형태
	- 서브쿼리의 결과 값을 메인쿼리에 제공하기 위한 목적
2. correlated(연관) 서브쿼리
	- 서브쿼리가 메인쿼리 컬럼을 가지고 있는 형태
	- 메인쿼리의 값이 서브쿼리에서 조건이 맞는지 확인 할때

#### 위치
1. 스칼라 서브쿼리(select): 서브쿼리 결과를 하나의 컬럼처럼 사용
2. 인라인뷰(from): 서브쿼리 결과를 하나의 테이블처럼 사용
3. where절 서브쿼리: 비교 상수 자리에 값을 전달하기 위한 목적

#### where 서브쿼리 종류

1. 단일행 서브쿼리: 1개의 행이 리턴되는 형태
	![[Pasted image 20250219142737.png]]
	![[Pasted image 20250219142657.png]]
2. 다중행 서브쿼리
	![[Pasted image 20250219142802.png]]
	![[Pasted image 20250219142821.png]]
3. 다중컬럼 서브쿼리
	![[Pasted image 20250219143146.png]]
	- 비교시 in을 사용
4. 상호연관 서브쿼리 - 메인쿼리와 서브쿼리의 비교를 수행
	![[Pasted image 20250219143320.png]]
* 상호연관 서브쿼리 연산 순서 
1) 메인쿼리 테이블 READ 
2) 메인쿼리 WHERE절 확인(SAL 확인) 
3) 서브쿼리 테이블 READ 
4) 서브쿼리 WHERE절 확인(다시 E1.DEPTNO 요구) 
5) E1.DEPTNO 값을 서브쿼리의 DEPTNO 컬럼과 비교하여 조건절 완성 
6) 위 조건에 성립하는 행의 그룹연산 결과 확인(AVG(SAL)) 
7) 위 결과를 메인쿼리에 전달하여 해당 조건을 만족하는 행만 추출 
	※ 상호연관 서브쿼리 사용 시 GROUP BY 생략 가능

#### 인라인 뷰
- 쿼리 안의 뷰의 형태로 테이블처럼 조회할 데이터를 정의하기 위해 사용
- 테이블명이 존재하지 않기 때문에 다른 테이블과 조인 시 반드시 테이블 별칭 명시 (단독으로 사용하는 경우 불필요) 
- WHERE절 서브쿼리와 다르게 ==서브쿼리 결과를 메인 쿼리의 어느 절에서도 사용할 수 있음 ==
- 인라인뷰의 결과와 메인쿼리 테이블과 조인할 목적으로 주로 사용 
- 모든 연산자 사용 가능
#### 스칼라 서브쿼리
- SELECT절에 사용하는 쿼리로, 마치 하나의 컬럼처럼 표현하기 위해 사용 (단, 하나의 출력 대상만 표현 가능)
- 각 행마다 스칼라 서브쿼리 결과가 하나여야 함(단일행 서브쿼리 형태)
- 조인의 대체 연산
- 스칼라 서브쿼리를 사용한 조인 처리 시 OUTER JOIN이 기본(값이 없더라도 생략되지 않고 NULL로 출력됨)

#### 서브 쿼리 주의 사항 
- 특별한 경우(TOP-N 분석 등)을 제외하고는 서브 쿼리절에 ORDER BY절을 사용 불가
- 단일 행 서브쿼리와 다중 행 서브쿼리에 따라 연산자의 선택이 중요

#### 집합 연산자
 - select 문 결과를 하나의 집합으로 간주
 - 두 집합의 컬럼이 동일하게 구성되어야 함(데이터 타입과 순서 일치가 필요)

##### 합집합
- union
	1. 중복 데이터는 한 번 출력
	2. 내부적으로 중복 데이터 제거를 위한 정렬 수행
	3. 중복 데이터 없으면 아래의 연산자를 사용하는게 좋음
- union all
	1. 그냥 모든 데이터 전체 출력

##### 교집합
- intersect
	1. 두 집합의 공통 행 출력

##### 차집합
- minus
	1. 말 그대로 차집합

##### 주의 사항
- 개별 select문에 order by 전달 불가능
- 잘 생각해보면 두 집합의 컬럼 수, 순서, 데이터 타입이 일치해야하는데 order by 사용시 그 규칙이 깨짐

#### 그룹함수
- 숫자 함수중 여러 값을 전달 -> 요약 값을 출력하는 다중행 함수
- group by 절에 의해 연산 결과 리턴
- null은 무시하고 연산 -> 말 그대로 없는 취급 함

##### count
- * 또는 단 하나의 컬럼만 전달 가능 
- * 사용 시 모든 컬럼의 값이 널일 때만 COUNT 제외
##### sum
##### avg
- NULL을 제외한 대상의 평균을 리턴
##### min/max
##### variance/stddev

#### group by function
- 여러 GROUP BY결과를 동시에 출력(합집합)

##### grouping sets(A, B, ....)
- a별, b별 그룹 연산 결과를 출력
![[Pasted image 20250224171200.png]]
즉, 30 CLERK 인 값이 있을때 DEPTNO와 JOB에서 한 번씩 결과에 집계가 된다
##### ROLLUP(A, B)
- A, (A, B) 로 그룹연산 결과 출력
- 나열 대상의 순서가 중요
- 전체 총 계도 출력함
##### CUBE(A, B)
- A, B, (A, B) 그룹으로 연산 결과 출력

#### [[3.1. window 함수]]
- 서로 다른 행의 비교나 연산을 위해 만든 함수
- group by 사용하지 않고 그룹 연산 가능

#### RANK(순위) 함수
##### RANK WITHIN GROUP
- 특정 값의 대한 순위 확인
```
SELECT RANK(a) WITHIN GROUP A
```
A에서 값 a의 순위

##### RANK() OVER(), DENSE_RANK(), ROW_NUMBER()
96


#### 비율 함수
##### RATIO_TO_REPORT
- 각 값의 비율 리턴
- order by 사용 불가능
- 0.333, 0.333, 0.333

##### CUME_DIST
- 각 행의 누적 비율
- order by 필수, 누적 비율의 순서 정할 수 있음
- ex) 0.333, 0.666, 1

##### ERCENT_RANK 
- PERCENTILE(분위수) 출력 
- 전체 COUNT중 상대적 위치 출력(0~1 범위 내) 
- ORDERY BY 필수
- 0, 0.5, 1

#### TOP N QUERY
- 페이징 처리를 효과적으로 수행하기 위해 사용 
- 전체 결과에서 특정 N개 추출

##### 1. ROWNUM 
![[Pasted image 20250224180920.png]]
![[Pasted image 20250224181040.png]]
예시와 같이 사용이 가능한데
- 절대적인 값이 아니라 = 는 불가능하고 크다 > 기호도 사용 불가능
 ![[Pasted image 20250224181503.png]]
- 다음과 같은 방법으로 rownum으로 가기전에 서브쿼리로 데이터 정렬을 미리 해두면 상위 5명의 값을 추출 가능
- ==between도 사이의 값을 추출하는건데 서브쿼리에서 번호를 만들지 않으면 시작 값이 정의 되지 않아서 안 된다고 한다???==
##### 3. FETCH 
- 출력될 행의 수를 제한하는 절 
- ORACLE 12C 이상부터 제공(이전버전에는 ROWNUM 주로 사용) 
- SQL Server 사용 가능
- ORDER BY절 뒤에 사용(내부 파싱 순서도 ORDER BY 뒤)
![[Pasted image 20250224182121.png]]
##### 4. TOP N(SQL Server)
- SQL Server에서의 상위 n개 행 추출 문법 
- 서브쿼리 사용 없이 하나의 쿼리로 정렬된 순서대로 상위 n개 추출 가능 
- WITH TIES를 사용하여 동순위까지 함께 출력 가능

![[Pasted image 20250224182245.png]]

#### 계층형 질의
- 하나의 테이블 내 각 행끼리 관계를 가질 때, 연결고리를 통해 행과 행 사이의 계층(depth)을 표현
- PRIOR의 위치에 따라 연결하는 데이터가 달라짐
![[Pasted image 20250224182528.png]]

![[Pasted image 20250224182731.png]]
0001 -> 1000   -> 1001 
			-> 1002
	 -> 1003   -> 1004 
		    -> 1005
	 -> 1006   -> 1007   -> 1008
				    -> 1009
				    -> 1010
				    -> 1011
계층형 질의 가상 컬럼 
1. LEVEL : 각 DEPTH를 표현(시작점부터 1) 
2. CONNECT_BY_ISLEAF : LEAF NODE(최하위노드) 여부(참:1, 거짓:0)

계층형 질의 가상 컬럼 - ==예시 함 작성해보기==
1. CONNECT_BY_ROOT 컬럼명 : 루트노드의 해당하는 컬럼값 
2. SYS_CONNECT_BY_PATH(컬럼, 구분자) : 이어지는 경로 출력 
3. ORDER SIBLINGS BY 컬럼 : 같은 LEVEL일 경우 정렬 수행 
4. CONNECT_BY_ISCYCLE : 계층형 쿼리의 결과에서 순환이 발생했는지 여부


### pivot and unpivot
#### 데이터 구조









### 정규화
   ## 모델링: 데이터 요구사항을 추상적이고 구조화된 형태로 표현하는 과정

특징
1. 단순화: 대상의 불필요한 세부사항을 제거하여 표현
2. 추상화: 대상을 일정한 형식으로 간략하게 표현
3. 명확화: 대상을 모호함 없이 정확하게 표현

관점
1. 데이터 관점: 데이터 저장, 접근, 관리를 정의
2. 프로세스 관점: 어떤 작업을 할 것인가, 이 작업들이 어떻게 조직, 조정 되는지 정의
3. 데이터와 프로세스 관점

유의점
1. 중복
2. 비유연성: 데이터와 프로세스의 정의를 최대한 분리하여 정의 
		-> 업무 변화에 모델이 변경 되지 않도록 유의
3. 비일관성: 데이터가 상반되거나 모순적이지 않는 내용으로 저장

요소
4. 대상
5. 속성
6. 관계

모델링 3단계
1. 개념적 모델링 - ERD 작성, 엔티티 추출과 관계를 중심으로 작성
2. 논리적 모델링 - 데이터 세부 속성, 제약조건을 포함하여 작성
3. 물리적 모델링  - 실제 데이터 베이스에 물리적으로 생성, 추상화 수준이 가장 낮음

## 스키마
- 데이터베이스 구조, 제약조건 명세를 기술한 메타데이터 집합
- 메타데이터 - 데이터의 속성 값이나 문맥을 정의한 데이터

종류
1. 외부 스키마: 사용자 관점에서 정의, 각 테이블에서 상호 작용이 필요한 데이터만 포함하여 작성
2. 개념 스키마: 데이터베이스의 논리적 구조로 정의
3. 내부 스키마: 데이터를 물리적으로 어떻게 저장할 것인지 정의

스키마의 독립성

논리적 독립성 : 논리적 데이터 구조가 변경되어도(개념 스키마 변경) 응용 프로그램에 영향을 주지 않는 특성

물리적 독립성 : 물리적 구조가 변경되어도(내부 스키마 변경) 개념/외부 스키마에 영향을 주지 않는 특성
## 엔티티
엔티티의 분류
- 유무형
	1. 유형엔티티: 물리적 형태가 존재함(고객)
	2. 개념엔티티: 물리적인 형태가 존재하지 않음(차량 종류)
	3. 사건엔티티: 업무를 수행하면서 발생함(주문)
- 발생 시점
	1. 기본엔티티: 원래 업무에 존재, 어떤 엔티티와의 관계로 생성되는 것이 아님, 고유 식별자 존재
	2. 중심엔티티: 기본엔티티로 발생, 업무에서 중심적인 역할, 많은 행위 엔티티를 생성
	3. 행위엔티티: 2개 이상의 부모엔티티로 발생(학생, 선생님 -> 수업)

## 속성
속성의 분류
	특성에 따른 분류
		1. 기본 속성: 업무로 추출된 모든 속성
		2. 설계 속성: 업무의 규칙화를 위해 기본 속성을 변형한 속성(ex 상품코드)
		3. 파생 속성: 다른 속성에 의해 생성된 속성
	엔티티 구성방식에 따른 분류
		1. PK
		2. FK
		3. 일반 속성
	분해 여부에 따른 속성
		1. 단일 속성: 하나의 의미(ex 상품 아이디)
		2. 복합 속성: 여러 개의 의미(ex 주소(시, 군, 구))
		3. 다중값 속성: 여러 개의 값을 가질 수 있는 경우(ex: 상품 리스트)

## 관계 
종류 - ERD에서는 구분 x
1. 존재적 관계
	- 한 엔티티가 다른 엔티티의 존재에 영향을 미침
2. 행위적 관계
	- 엔티티 간의 어떤 행위가 있음을 의미

구성
1. Cardinality - 차수 (1:M)
2. 관계명
3. optionality - 선택성: 엔티티의 인스턴스가 관계 없이 독립적으로 존재 할 수 있는지의 여부

==관계의 페어링==: 인스턴스가 개별적으로 관계를 가지는 것

차수와 페이링 차이
- 관계의 차수는 하나의 엔터티와 다른 엔터티 간의 레코드 연결방식을 나타냄
- 관계의 페어링은 두 엔터티 간의 특정 연결을 설명하고 추가 정보를 제공하는 용도로 사용
ex)    차수 - 학생 테이블 - 수업 테이블은 M 대 N 관계
    페이링 - 학생 A가 강의 B를  2024에 수강했고 성적은 A이다
	
## 식별자

분류

대표성
	- 주식별자
		1. 유일성, 최소성을 만족하는 엔티티를 대표하는 식별자
		2. 각 인스턴스의 구분자
		3. 타 엔티티와 참조관계로 연결 가능
	- 보조식별자
		1. 인스턴스의 구분자
		2. 대표성을 가지지 못해 참조 관계 연결 불가능
		3. 유일성, 최소성을 만족

생성여부
	- 내부식별자
		 참조 없이 엔티티 내부에서 스스로 생성
	- 외부식별자
		다른 엔티티와 관계로 생성(FK)
속성 수
	- 단일 식별자
		하나의 속성으로 구성
	- 복합식별자
		2개 이상의 속성으로 구성
대체 여부
	- 본질식별자(원조 식별자)
		비즈니스 프로세스에서 만들어진 식별자(ex userId)
	- 인조식별자
		인위적으로 만들어지는 식별자(ex auto_increment)

## [[1.1. 정규화]]

## 반정규화
- 데이터베이스 성능을 위해 데이터 중복을 허용하고 조인을 줄이는 방법

## 관계
- 엔티티의 인스턴스 사이의 논리적 연관성
- 관계를 맺는다 = 부모의 식별자를 자식에게 상속하고 조인키로 활용

분류
- 존재 관계: 엔티티 간의 상태 ex) 부서 - 사원
- 행위 관계: 엔티티 간의 행위 ex) 주문 - 고객
## 조인
데이터 중복을 피하기 위해서 정규화로 분리 -> 이 테이블의 관계를 다시 연결하는 과정

## 계층형 데이터 모델 - 예시 읽어보기
- 자기 자신끼리 관계 발생
- 하나의 엔티티 내의 인스턴스끼리 계층 구조를 가지는 경우
- 이 인스턴스를 연결하는 조인은 self조인이라고 함

## 상호배타적 관계
- 두 테이블 중 하나만 연결 가능한 관계(독립 x)
![[Pasted image 20250217193718.png]]
## 트랜잭션
- 하나의 연속적인 업무 단위
- 트렌잭션에 의한 관계는 필수적인 관계 형태를 가짐
- ex) 고객의 잔고를 확인 -> 고객의 잔고에서 차감
- 이 과정들은 모두 성공하거나 모두 취소되어야하고, 서로 독립적으로 발생하면 안 됨

## ERD 표기법
IE 표기법
- 원을 사용하여 필수적 관계와 선택적 관계를 구분
- 원 O -> 선택적 관계
- 원 X -> 필수적 관계
- null의 허용여부를 알 수 없음

바커 표기법
- 실선과 점선을 사용하여 필수적 관계와 선택적 관계를 구분
- 실선 -> 필수적 관계
- 점선 -> 선택적 관계
- 속성 앞 동그라미로 null의 허용여부를 확인 가능
## NULL
- 컬럼에서 공백인 데이터
- null이 포함된 컬럼의 연산결과는 null을 반환 -> 사전에 치환이 필수
- SUM, AVG, MIN, MAX 등의 함수는 항상 NULL 을 무시한다

## 식별자 구분

본질식별자
- 업무에 의해 만들어진 식별자(필수적인 요소)
인조식별자
- 필수적인 것은 아니지만 편의에 의해 생성된 식별자

문제점
- 중복 데이터 발생 가능성
- 불필요한 인덱스 생성
# 서버

### 정의 
- 인터넷 네트워크 환경에서 다른 컴퓨터에게 데이터나 기능을 제공하는 것 즉, 서비스를 제공하는 역할을 하는 것
- 서버는 요청을 받아들이고, 처리한 후 응답을 클라이언트에게 반환하는 역할

### 종류

1. 웹 서버 : 웹사이트 서비스를 제공하기 위한 서버
2. 도메인 서버 : 도메인을 관리하기 위한 서버
3. 이미지 서버 : 이미지를 관리하기 위한 서버
4. 이메일 서버 : 이메일을 관리하기 위한 서버
5. DB 서버 : 데이터 정보를 관리하기 위한 서버
6. 게임 서버 : 게임을 제공하기 위한 서버
7. 미디어 서버 : 미디어를 제공 관리하기 위한 서버

서버 프로그램의 종류
- apache
- Nginx

![[Pasted image 20240919203423.png]]


# 인터넷

인터넷이란 data를 전달하는 장치들이 이루는 거대한 network망을 의미하며 Application에게 통신 서비스를 제공하는 존재를 의미합니다.

## 인터넷 구성

인터넷은 여러 형태의 network와 그 안에 sub-network로 구성이 됩니다. 또한 network는 다양한 entity인 Network Edge, Access network, Network Core 등으로 이루어져 있습니다.

### Network Edge

Network Edge란 끝에 있는 entity를 의미하며 End System으로 구성이 되어있습니다. 대표적인 End System으로는 web browser, email client, 스마트폰 그리고 server 등 실제 application이 여기에 포함이 된다.

### Access Network

Access Network란 End system이 Internet의 첫 부분과 연결되는 구간으로 대표적으로 우리가 인터넷에 접속할 때 사용하는 랜선, 와이파이 등이 있습니다.

### Network Core

Network Core란 Network의 핵심 부분으로 End system의 정보를 실어 나르는 역할을 합니다. 대표적으로 router가 있습니다. (router는 받은 데이터를 적절히 전달하는 역할을 합니다.)


## 인터넷 통신

endSystem간 패킷을 주고 받는 것
![[Pasted image 20240919183456.png]]

위와 같은 방식으로 패킷이 이동을 한다면 다른 기기의 정보를 알 수 없기 때문에 여러 가지 문제점을 생각할 수 있다.

1. **만약 상대의 컴퓨터가 꺼져있다면?**
2. **만약 중간에 패킷이 소실이 된다면?**
3. **뒤에 보낸 패킷이 먼저 도착한다면?**
4. **컴퓨터에 프로그램이 여러 개가 켜져 있다면?**

이를 해결하기 위해서는 PORT와 TCP, UDP가 필요하다

### TCP

TCP란 Transmission Control Protocol(전송 제어 프로토콜)의 약자로 연결 보증을 해준다.

### 3 way-handshake

상대방의 컴퓨터 서버가 꺼져있다고 가정해 보겠습니다.

보내는 입장에서는 packet에 도착지의 IP와 PORT만 넣어서 보내고 router는 IP와 PORT를 보고 목적지로 보냅니다.

하지만 목적지의 컴퓨터는 꺼져있기 때문에 메시지를 받을 수 없습니다.

![[Pasted image 20240919183920.png]]

그렇기에 데이터를 보내기에 앞서 클라이언트는 상대방이 있는지 확인해야 합니다.

그때 사용하는 것이 3 way-handshake입니다.

1. **SYN**: 클라이언트가 서버에 **SYN(동기화)** 메시지를 보내면서 연결을 시작합니다.
2. **SYN-ACK**: 서버는 클라이언트의 요청을 받고 **SYN-ACK(동기화-응답)** 메시지로 이를 확인하고 응답합니다.
3. **ACK**: 클라이언트는 서버에 **ACK(응답)** 메시지를 보내고, 이로써 연결이 성립됩니다

![[Pasted image 20240919184017.png]]

### 데이터 전달 보증

2번 문제처럼 Packet이 중간에 소실되어 있다고 가정하겠다.
![[Pasted image 20240919184055.png]]
보내는 입장이나 받는 입장에서는 패킷이 소실되었는지 아직 도착을 안한 건지 알 수 없습니다. 그래서 받았음을 ACK를 통해서 받았음을 확인 한다.
### 순서 보장

보통 Packet을 보낼 때 일정량 이상이 된다면 끊어서 보낸다.
이때 나중에에 보낸 packet이 먼저 도착할 수도 있다.

TCP는 패킷에 **SequenceNumber**라는 순서를 붙임으로써 이 문제를 해결한다.

1. 그럼 패킷 순서가 1000~3000이 있다고 가정하고 ACK를 순차적으로 받을 것이다. 이때 1000씩 끊어서 받았던 ACK값을 1000이후에 3000을 받게 된다면 2000번이 누락 되었다고 판단하고 2000번을 다시 요청하게 된다.

3. timeout이라는 방식을 통해서 일정 시간동안 요청에 대한 응답이 없으면 다시 packet을 요청하게 된다.

### 궁금했던 점

만약 3000패킷이 전송을 받아서 2000번을 다시 요청하게 되었고 뒤 늦게 2000이 전송이 되었다면 새롭게 요청받은 2000번 패킷은 어떻게 되는가?
- **재전송된 2000번 패킷**은 **중복 패킷**으로 간주되어, TCP가 이를 감지하고 무시하고 다시 필요한 패킷을 요청한다.

![[Pasted image 20240919184225.png]]

### UDP

**UDP**(User Datagram Protocol)는 **비연결형 통신 프로토콜**로, 데이터 전송 시 연결 설정을 하지 않고 바로 패킷을 전송하는 방식입니다. TCP와 달리 **신뢰성**보다는 **속도**와 **효율성**에 중점을 둡니다.

#### UDP의 특징:

1. **비연결형**: 송신자와 수신자가 연결을 설정하지 않고 데이터를 전송하며, 데이터가 도착했는지 확인하지 않습니다.
2. **빠른 전송 속도**: 연결 설정이나 패킷 재전송 과정을 생략하므로 속도가 빠릅니다.
3. **데이터 무결성 보장 없음**: 패킷이 유실되거나 순서가 뒤바뀔 수 있으며, 이를 처리하는 책임은 애플리케이션에 있습니다.
4. **헤더가 가볍다**: UDP는 TCP보다 헤더가 작아 네트워크 자원을 적게 사용합니다.

#### UDP 통신의 주요 단계:

1. **데이터그램 송신**: 송신 측에서 데이터를 **데이터그램**으로 전송합니다. 데이터그램은 패킷의 일종이며, 수신 측이 받을 수 있는 IP 주소와 포트를 통해 전송됩니다.
2. **데이터그램 수신**: 수신 측은 특정 포트를 통해 해당 데이터그램을 수신합니다.
3. **패킷 유실이나 순서 제어 없음**: UDP는 패킷의 유실이나 순서를 보장하지 않기 때문에, 수신 측에서 이를 처리하거나 무시할 수 있습니다.

### NestJS에서 UDP 구현

NestJS는 기본적으로 TCP 기반의 HTTP 서버를 구축하는데 자주 사용되지만, UDP 통신도 가능합니다. NestJS는 **Transport Layer**에서 UDP를 지원하여 간단하게 UDP 서버와 클라이언트를 구현할 수 있습니다.

## WAS

**WAS**(Web Application Server, 웹 애플리케이션 서버)는 **웹 애플리케이션**을 실행하고 클라이언트(웹 브라우저 등)와 **동적**으로 통신할 수 있는 서버입니다. WAS는 일반적인 웹 서버와 달리, 웹 페이지와 클라이언트 요청에 대한 **동적 처리**(예: 데이터베이스 쿼리, 비즈니스 로직 처리)를 수행하는 데 중점을 둡니다. 클라이언트의 요청에 따라 **프로그램이 실행**되고 그 결과가 웹 브라우저에 응답으로 전달됩니다.

### WAS의 기본 개념

- **WAS는 웹 애플리케이션을 호스팅**하고 클라이언트의 HTTP 요청에 맞춰 데이터를 처리하며, 결과를 응답합니다.
- **웹 서버**(예: Apache, Nginx)와 **애플리케이션 서버**의 기능을 결합한 개념입니다. 웹 서버는 정적 파일(HTML, CSS, JS 등)을 전달하고, WAS는 **동적 웹 페이지 생성**과 **비즈니스 로직 처리**를 담당합니다.
- **프로그래밍 언어**를 기반으로 동작하는 웹 애플리케이션(WAR 파일 등)을 실행하고, 클라이언트와 데이터베이스 간의 중간 계층에서 데이터를 처리하는 역할을 합니다.
- portForwarding - 서버와 클라이언트에 reverseProx를 해줘야 통신이 가능하다
- 
![[Pasted image 20240919184529.png]]

### nest에서는 이미 was 구조로 역할을 수행 할 수 있게 만든 프레임 워크이다.

 와닫는 예시
 
과거에는 인터넷 사용자가 지금과 달리 많지 않았습니다.
예를 들어, 웹 사이트 A의 사용자가 10명이고 웹 사이트 A는 로그인을 한 사용자마다 다른 화면
(ex. 각 사용자마다 작성했던 게시글을 다르게 하는 등)을 보여준다고 해봅시다.
이때는 사용자가 10명이라 그냥 html페이지(js 포함)를 10개를 만들면 됩니다.
미리 정해진**(정적인)** 콘텐츠를 준비해두고 요청이 오면 응답으로 주는 것이 아닌,
요청이 올 때마다 해당 요청에 적절한 콘텐츠를 만들 수 있다면**(동적인)** 되겠죠?